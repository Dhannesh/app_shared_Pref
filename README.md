# APP Shared Pref

we'll see how you can store data to and read data from your local mobile device using SharedPreferences. SharedPreferences gives you a very simple store for your locally persisted data. If the data that you want to store in the local device is fairly simple and can be expressed in the form of key-value pairs, SharedPreferences is the right local persistence for you. As the name implies, SharedPreferences is often used to store preference data for your application, such as the theme of your application, the font size of your application. Each user can set his or her own preference that can be applied throughout the app. In order to use **SharedPreferences**, let's open pubspec.yaml and add in the right dependency. 

Note the UI simply has three text fields, one for Key, one for Value, and one for the Type of the value. And of course, there are the Set and Get buttons at the very bottom of the screen. I have an import statement for preferences_util.dart, that is the utility helper class that I'll be using to work with SharedPreferences.
PreferencesUtil, you'll see is a singleton class, so there is just a single instance of PreferencesUtil that we'll use across all of the pages of any app that we build.
These are the TextEditingControllers for the three text fields  that we see in the preferences_page.dart, the Key, Value, and Type controllers. In the initState method, I call preferencesUtil.init to initialize my preferencesUtil helper class. This will access and set up the single instance of the SharedPreferences plugin.

The SharedPreferences plugin allows you to store only primitive values as key-value pairs. So, you can store integers, booleans, strings, and list of strings, but you can't store complex data types.

And then I have the third TextField, which is where we'll specify the Type of the value that we want to store using SharedPreferences. This is important because based on the type of data that we want to store, we need to invoke a different API on the SharedPreferences plugin.

The first one is to be able to set a new key-value pair using SharedPreferences. Observe that it's onPressed handler is empty. The second button, the Get button is to be able to retrieve the value of a preference given a key. Again, its onPressed handler is currently empty. We'll fill those in in a little bit, but meanwhile, let's take a look at the more interesting file preferences_util.dart. This is a wrapper helper class that I have defined in the utils package. I have a reference to the SharedPreferences plugin. It has the late modifier because I'll initialize it in the init method. The _currentInstance variable holds a reference to the singleton instance of this class, the PreferencesUtil class, so this is the only object that we'll create and use across our app. Observe the question mark. The _currentInstance is a nullable object. I have an _internal constructor for PreferencesUtil and I have a factory constructor. the factory constructor , if I already have an object of the PreferencesUtil class defined, that is what I'm going to return from the factory constructor. If no _currentInstance is present, I'll use the internal constructor to create a _currentInstance. When we first use the PreferencesUtil, you can invoke the init method. Within the init method, I call await on SharedPreferences.getInstance to asynchronously retrieve an instance of the SharedPreferences plugin that we'll use to access and set key-value pairs. you'll see I have a number of setter methods. Notice that in order to set a key-value pair using SharedPreferences, you need to use the await keyword because setting of a preference is an asynchronous operation. This is because the SharedPreference plugin initially writes out the key-value pair to memory and then asynchronously persists it to disk, just as we have defined setters for the different primitive value types that we can set using SharedPreferences. We have getters to retrieve different primitive value types given a key. Here I have getter functions and each of these getter functions retrieve a value of a different type. They take a String key as an input argument and the return value is always different. Notice in the function definition, the return values all have question marks indicating that each get invocation on the SharedPreferences plugin can return a null value.  This is possible because it's possible that a particular key-value pair hasn't been set. In that case, if you try to get using a particular key, the return value will be null. Another thing to note in the body of these methods, notice there is no await keyword. That's because retrieving a value given a key is not an asynchronous operation. It's a synchronous operation. If you want to know what keys have been stored using SharedPreferences, you can invoke the getKeys function. This is my helper method, which invokes _sharedPreferences.getKeys to retrieve a set of all keys stored using SharedPreferences.

## Retrieving Key Value Pairs Using SharedPreferences 
Now that you've seen what the basic structure of the app looks like, let's wire up our onPressed handlers so that we can set preferences and we can retrieve the preferences that we previously set. I'm currently in the preferences_page.dart file and within the build method of our PreferencesPageState. you can see that I check to see whether the text is empty for any of the text fields, so if any of the text fields are empty, then we do nothing. All of the text fields need to be specified before we can use the Set button. Now, because we are using a text field, the value is initially available in the form of a string, we'll need to convert it to the right type before we actually set the SharedPreferences. You can see then I switch on the valueType that is the type of the value that we want to set whether it's an integer, boolean, and so on then I have case statements for the various types.

I handle the case where the type we're setting is an integer. In this case, I call int.parse valueString into an integer value, and then we call preferencesUtil.setInt key and value. I check to see if the valueString is equal to the string true, if yes, we accept that as the boolean true, all other strings will be considered false. Now, let's scroll down and wire up the onPressed handler of the getter as well. This is the onPressed handler, While retrieving preferences using our app, you only need to specify the key and the value type.  I have a switch statement switching on the type of value that we want to retrieve from SharedPreferences. With SharedPreferences, you want the data to persist even after the app is restarted and we can check this. 

## Storing the Last Search Term in SharedPreferences
Now that you know how to use SharedPreferences, we can use it for something useful. In this demo, we'll see how you can use SharedPreferences to store the most recently searched for term in your app. So, let's say the user can perform a number of searches and you always want to ensure that you store the last search term. 

I have a TextEditingController, the _searchController, that is associated with the Search text field that you can see in the my_home_page.dart, I have a variable that stores the last _searchTerm which is initialized to No searches yet, and if you look on the app at the very bottom, you see displayed No searches yet. Also in the init method, I call preferencesUtil.init to initilize the plugin and get an instance of the SharedPreferences plugin.

This is the Search text field that you see at the very top of the app. Now, the suffix of the text field has an IconButton that is the search button and its onPressed handler. Now, we won't actually be performing any searches. But when we press the search button, we check to see whether the text in the Search text field isNotEmpty. If it's not empty, that is there is some text. I invoke preferencesUtil.setSearchTerm and set the last search term in SharedPreferences,  Now, below that, I have an ElevatedButton that is for Recent searches.

In the onPressed handler for this ElevatedButton, I call setState and get the last search term from SharedPreferences, preferencesUtil. getSearchTerm. If it's null, I just set it to empty. Here I've retrieved the last search term and we'll display this in our page. Scroll a little further down and you'll see a ListTile. You can see the title of this ListTile which displays the last term that we searched for, stored in search term. There is also a delete Icon. Tapping on the delete Icon will basically call preferencesUtil.removeSearchTerm which does deletes the key entirely from SharedPreferences. Now, let's take a look at preferences_util.dart. This is where we interact with the SharedPreferences plugin. Now, the basic structure of PreferencesUtil is what we have seen before. It's set up as a singleton class. 

## Using SharedPreferences for Autocomplete
In this demo, we'll use SharedPreferences in a slightly more interesting way. Instead of storing just the last search term, we'll store a list of search terms and use that within an autocomplete widget. Not only will you see a real-world use case for SharedPreferences, you'll also see how we can set up autocomplete in Flutter. Here is the PreferencesUtil class that we'll use once again our helper to work with preferences, the basic structure of this class is the same. Since we're going to be dealing with a list of search terms, all of the terms that the user has searched for in the app, we'll be saving preferences as a list of strings. You can see the method setSearchTerms, it takes in a list of strings as an input argument and calls _sharedPreferences.setStringList to set the search_terms key to a list of string values. I have getSearchTerms which calls _sharedPreferences.getStringList to get a list of recently searched terms. Now, in order to use the recently searched terms, we are going to set up an autocomplete widget in our app. The basic structure of the MyStore app is the same. I have my MyHomePage StatefulWidget. What I'm going to change is the MyHomePageState that is I'm going to change the UI and how we actually use the search terms. let's take a look in auto_complete_page.dart. Now, within the init state, I call preferencesUtil.init, and then I specify a then callback. After the SharedPreferences have been initialized, I'm going to basically update my current state. I call preferencesUtil.getSearchTerms to get the current list of search terms and if there are search terms that is terms != null, I update the searchTermsList with these search terms that I've retrieved from SharedPreferences, _searchTermsList.addAll(terms). the most interesting widget that you are going to be using in this app is the autocomplete widget, so that's what I'm going to focus on. The rest of the stuff is familiar to you and I'll leave it to you to explore on your own. I've defined the autocomplete widget on line 64 using RawAutocomplete. This is a widget for helping the user make a selection by entering some text and then choosing from amongst a list of options. We have to build up number of properties for this autocomplete. 

This builds the field whose input is used to get the options that need to be displayed and you can see that the fieldViewBuilder it takes in a number of different input arguments but it essentially what we've used here is a TextField.

Note the onSubmitted callback invoked when the user has entered a search term. Now, within this, notice I call setState, essentially if the search term that the user has entered is not already present in our searchTermsList, I add the new search term that the user has entered, searchTermsList.add(value) and I update the SharedPreferences. The SharedPreferences will now include the new search term. If you scroll further down, another property that we've set on the RawAutocomplete is the optionsViewBuilder. This is the callback that builds the selectable options widgets from a list of options objects. This is essentially the widget that will be displayed to show our autocomplete options and it will be displayed below the text field. Now, the widget is a Card Embedded within this card is a list view of search term options, which I construct using a ListView.builder. For every option in our autocomplete, we construct an InkResponse widget. When we tap on a particular option, we invoke the onSelected callback for that option. That's the part of the RawAutocomplete and we also show a SnackBar indicating the search term that we are currently searching for. we have the ListTile that actually displays the option. Now, that we've seen the basic structure of the app and how we can use SharedPreferences for autocomplete, 

## Storing User Preferences in an Application 
I'll show you how you can use SharedPreferences to save the background color of your app and maybe the display image you want to show on your app. The images subfolder is parallel to the lib subfolder, and all of the images that are in there will now be available to your app. There are a number of images here in this images folder and these should be available as a part of the assets that are included with this video. You can see that there is an image right in the center and there are three colors which you can choose from for the background. So, the background you can choose to be red, blue, or green, the default background is yellow. You can also edit the app using a dialog. 
You can see that the 'app_setting.dart' is a StatefulWidget. If you look within the state class you can see that I have a String that points to the _settingImage.  we have a list of _images that the user can choose from to update his or her preferences, car, ducky, dino, engine, and robot.  I've initialized the default _settingColor that is the yellow that you see here on screen. And then I have a list of _colors that is the red, blue, and green options that you see on screen.
And then I have two setters defined, setColor  which updates the _settingColor to the new color specified, and setImage which updates the current image to a new one.

Each colored rectangle is an InkResponse widget. Notice the onTap handlers for each of these InkResponse widget, we just update the color to be equal to the color displayed that is the background color of the app to be equal to the color displayed. Scrolling further down the _showMyDialog method here simply displays an AlertDialog that allows you to choose the image you want displayed in your app. Notice that the AlertDialog embeds an Autocomplete widget, Here I've used the Autocomplete widget rather than the RawAutocomplete because my Autocomplete options are rather simple and I don't need the flexibility of the RawAutocomplete, which allows me to configure my widget in a more customized manner.

Here I have the optionsBuilder which takes in the textEditingValue. If the text is empty then we show all of the image options, otherwise, we only show those options which contain the text that the user has entered in the Autocomplete widget. This filtering operation is performed. Once we've selected a particular Autocomplete option, the onSelected callback is invoked  where we call setImage to update the image displayed, and down below we have the ColorButton widget. This basically displays a button with a certain background color. An important note here, I haven't added any preference functionality yet, which means any changes I make to the preferences of my app, those will not be persisted if I restart the app.

You should get a nice Autocomplete in this AlertDialog allowing you to pick from the images that are available. I'll pick the robot image, click on Change. Having made these changes, let's now stop and restart the application. Stopping the application running is like stopping the app on your phone, and let's now bring the application up once again. Clicking on the run button should get the application up and running again and observe that we still have the red background and the robot image. These have been saved in SharedPreferences on disk and have been reloaded from disk when you restarted the app.